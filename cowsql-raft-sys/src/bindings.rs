/* automatically generated by rust-bindgen 0.69.4 */

pub const RAFT_VERSION_MAJOR: u32 = 0;
pub const RAFT_VERSION_MINOR: u32 = 22;
pub const RAFT_VERSION_RELEASE: u32 = 1;
pub const RAFT_VERSION_NUMBER: u32 = 2201;
pub const RAFT_ERRMSG_BUF_SIZE: u32 = 64;
pub const RAFT_TRACER_DIAGNOSTIC: u32 = 1;
pub const RAFT_UPDATE_CURRENT_TERM: u32 = 1;
pub const RAFT_UPDATE_VOTED_FOR: u32 = 2;
pub const RAFT_UPDATE_ENTRIES: u32 = 4;
pub const RAFT_UPDATE_SNAPSHOT: u32 = 8;
pub const RAFT_UPDATE_MESSAGES: u32 = 16;
pub const RAFT_UPDATE_STATE: u32 = 32;
pub const RAFT_UPDATE_COMMIT_INDEX: u32 = 64;
pub const RAFT_UPDATE_TIMEOUT: u32 = 128;
extern "C" {
    pub fn raft_version_number() -> ::std::os::raw::c_int;
}
pub const RAFT_NOMEM: _bindgen_ty_1 = 1;
pub const RAFT_BADID: _bindgen_ty_1 = 2;
pub const RAFT_DUPLICATEID: _bindgen_ty_1 = 3;
pub const RAFT_DUPLICATEADDRESS: _bindgen_ty_1 = 4;
pub const RAFT_BADROLE: _bindgen_ty_1 = 5;
pub const RAFT_MALFORMED: _bindgen_ty_1 = 6;
pub const RAFT_NOTLEADER: _bindgen_ty_1 = 7;
pub const RAFT_LEADERSHIPLOST: _bindgen_ty_1 = 8;
pub const RAFT_SHUTDOWN: _bindgen_ty_1 = 9;
pub const RAFT_CANTBOOTSTRAP: _bindgen_ty_1 = 10;
pub const RAFT_CANTCHANGE: _bindgen_ty_1 = 11;
pub const RAFT_CORRUPT: _bindgen_ty_1 = 12;
pub const RAFT_CANCELED: _bindgen_ty_1 = 13;
pub const RAFT_NAMETOOLONG: _bindgen_ty_1 = 14;
pub const RAFT_TOOBIG: _bindgen_ty_1 = 15;
pub const RAFT_NOCONNECTION: _bindgen_ty_1 = 16;
pub const RAFT_BUSY: _bindgen_ty_1 = 17;
pub const RAFT_IOERR: _bindgen_ty_1 = 18;
pub const RAFT_NOTFOUND: _bindgen_ty_1 = 19;
pub const RAFT_INVALID: _bindgen_ty_1 = 20;
pub const RAFT_UNAUTHORIZED: _bindgen_ty_1 = 21;
pub const RAFT_NOSPACE: _bindgen_ty_1 = 22;
pub const RAFT_TOOMANY: _bindgen_ty_1 = 23;
#[doc = " Error codes."]
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Return the error message describing the given error code."]
    pub fn raft_strerror(errnum: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
#[doc = " Hold the value of a raft server ID. Guaranteed to be at least 64-bit long."]
pub type raft_id = ::std::os::raw::c_ulonglong;
#[doc = " Hold the value of a raft term. Guaranteed to be at least 64-bit long."]
pub type raft_term = ::std::os::raw::c_ulonglong;
#[doc = " Hold the value of a raft entry index. Guaranteed to be at least 64-bit long."]
pub type raft_index = ::std::os::raw::c_ulonglong;
#[doc = " Hold a time value expressed in milliseconds since the epoch."]
pub type raft_time = ::std::os::raw::c_ulonglong;
#[doc = " A data buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_buffer {
    pub base: *mut ::std::os::raw::c_void,
    pub len: usize,
}
#[doc = " Customizable tracer for debugging, logging and metrics purposes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_tracer {
    #[doc = " Implementation-defined state object."]
    pub impl_: *mut ::std::os::raw::c_void,
    #[doc = " Version of the raft_tracer structure. Must be at least 2."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Emit an event of the given @type code. The @info object contains\n details about the event and its format depends on the event @type.\n\n Type codes from #1 to #255 are reserved for traces defined by the\n core library.\n\n Type codes from #256 to #65535 are reserved for events defined by\n specific #raft_io backends.\n\n Type codes from #65535 onwards can be used by user applications."]
    pub emit: ::std::option::Option<
        unsafe extern "C" fn(
            t: *mut raft_tracer,
            type_: ::std::os::raw::c_int,
            info: *const ::std::os::raw::c_void,
        ),
    >,
}
#[doc = " Information passed as @info argument to #raft_tracer->trace() for\n traces generated by #raft objects."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raft_tracer_info {
    #[doc = " Version of the #raft_tracer_info structure. Must be at least 1."]
    pub version: ::std::os::raw::c_int,
    pub __bindgen_anon_1: raft_tracer_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union raft_tracer_info__bindgen_ty_1 {
    pub diagnostic: raft_tracer_info__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_tracer_info__bindgen_ty_1__bindgen_ty_1 {
    pub level: ::std::os::raw::c_int,
    pub message: *const ::std::os::raw::c_char,
    pub file: *const ::std::os::raw::c_char,
    pub line: ::std::os::raw::c_int,
}
pub const RAFT_STANDBY: _bindgen_ty_2 = 0;
pub const RAFT_VOTER: _bindgen_ty_2 = 1;
pub const RAFT_SPARE: _bindgen_ty_2 = 2;
#[doc = " Server role codes."]
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
#[doc = " Hold information about a single server in the cluster configuration.\n WARNING: This struct is encoded/decoded, be careful when adapting it."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_server {
    pub id: raft_id,
    pub address: *mut ::std::os::raw::c_char,
    pub role: ::std::os::raw::c_int,
}
#[doc = " Hold information about all servers currently part of the cluster.\n WARNING: This struct is encoded/decoded, be careful when adapting it."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_configuration {
    pub servers: *mut raft_server,
    pub n: ::std::os::raw::c_uint,
}
extern "C" {
    #[doc = " Initialize an empty raft configuration."]
    pub fn raft_configuration_init(c: *mut raft_configuration);
}
extern "C" {
    #[doc = " Release all memory used by the given configuration object."]
    pub fn raft_configuration_close(c: *mut raft_configuration);
}
extern "C" {
    #[doc = " Add a server to a raft configuration.\n\n The @id must be greater than zero and @address point to a valid string.\n\n The @role must be either #RAFT_VOTER, #RAFT_STANDBY, #RAFT_SPARE.\n\n If @id or @address are already in use by another server in the configuration,\n an error is returned.\n\n The @address string will be copied and can be released after this function\n returns."]
    pub fn raft_configuration_add(
        c: *mut raft_configuration,
        id: raft_id,
        address: *const ::std::os::raw::c_char,
        role: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Encode the given configuration object.\n\n The memory of the returned buffer is allocated using raft_malloc(), and\n client code is responsible for releasing it when no longer needed."]
    pub fn raft_configuration_encode(
        c: *const raft_configuration,
        buf: *mut raft_buffer,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Decode the given configuration object."]
    pub fn raft_configuration_decode(
        buf: *const raft_buffer,
        c: *mut raft_configuration,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Hash function which outputs a 64-bit value based on a text and a number.\n\n This can be used to generate a unique ID for a new server being added, for\n example based on its address and on the current time in milliseconds since\n the Epoch.\n\n It's internally implemented as a SHA1 where only the last 8 bytes of the hash\n value are kept."]
    pub fn raft_digest(
        text: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_ulonglong;
}
pub const RAFT_COMMAND: raft_entry_type = 1;
pub const RAFT_BARRIER: raft_entry_type = 2;
pub const RAFT_CHANGE: raft_entry_type = 3;
#[doc = " Log entry types."]
pub type raft_entry_type = ::std::os::raw::c_uint;
#[doc = " A single entry in the raft log.\n\n An entry that originated from this raft instance while it was the leader\n (typically via client calls to raft_apply()) should normally have a @buf\n attribute referencing directly the memory that was originally allocated by\n the client itself to contain the entry data, and the @batch attribute set to\n #NULL.\n\n An entry that was received from the network as part of an AppendEntries RPC\n or that was loaded from disk at startup should normally have a @batch\n attribute that points to a contiguous chunk of memory that contains the data\n of the entry itself plus possibly the data for other entries that were\n received or loaded with it at the same time. In this case the @buf pointer\n will be equal to the @batch pointer plus an offset, that locates the position\n of the entry's data within the batch.\n\n When the @batch attribute is not #NULL the raft library will take care of\n releasing that memory only once there are no more references to the\n associated entries.\n\n This arrangement makes it possible to minimize the amount of memory-copying\n when performing I/O."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_entry {
    pub term: raft_term,
    pub type_: raft_entry_type,
    pub buf: raft_buffer,
    pub batch: *mut ::std::os::raw::c_void,
}
#[doc = " Hold the arguments of a RequestVote RPC.\n\n The RequestVote RPC is invoked by candidates to gather votes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_request_vote {
    pub version: ::std::os::raw::c_uchar,
    pub term: raft_term,
    pub candidate_id: raft_id,
    pub last_log_index: raft_index,
    pub last_log_term: raft_index,
    pub disrupt_leader: bool,
    pub pre_vote: bool,
}
#[doc = " Hold the result of a RequestVote RPC."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_request_vote_result {
    pub version: ::std::os::raw::c_uchar,
    pub term: raft_term,
    pub vote_granted: bool,
    pub pre_vote: bool,
    pub features: ::std::os::raw::c_ushort,
    pub capacity: ::std::os::raw::c_ushort,
}
#[doc = " Hold the arguments of an AppendEntries RPC.\n\n The AppendEntries RPC is invoked by the leader to replicate log entries. It's\n also used as heartbeat (figure 3.1)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_append_entries {
    pub version: ::std::os::raw::c_uchar,
    pub term: raft_term,
    pub prev_log_index: raft_index,
    pub prev_log_term: raft_term,
    pub leader_commit: raft_index,
    pub entries: *mut raft_entry,
    pub n_entries: ::std::os::raw::c_uint,
}
#[doc = " Hold the result of an AppendEntries RPC (figure 3.1)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_append_entries_result {
    pub version: ::std::os::raw::c_uchar,
    pub term: raft_term,
    pub rejected: raft_index,
    pub last_log_index: raft_index,
    pub features: ::std::os::raw::c_ushort,
    pub capacity: ::std::os::raw::c_ushort,
}
#[doc = " Hold the arguments of an InstallSnapshot RPC (figure 5.3)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_install_snapshot {
    pub version: ::std::os::raw::c_uchar,
    pub term: raft_term,
    pub last_index: raft_index,
    pub last_term: raft_term,
    pub conf: raft_configuration,
    pub conf_index: raft_index,
    pub data: raft_buffer,
}
#[doc = " Hold the arguments of a TimeoutNow RPC.\n\n The TimeoutNow RPC is invoked by leaders to transfer leadership to a\n follower."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_timeout_now {
    pub version: ::std::os::raw::c_uchar,
    pub term: raft_term,
    pub last_log_index: raft_index,
    pub last_log_term: raft_index,
}
pub const RAFT_APPEND_ENTRIES: raft_message_type = 1;
pub const RAFT_APPEND_ENTRIES_RESULT: raft_message_type = 2;
pub const RAFT_REQUEST_VOTE: raft_message_type = 3;
pub const RAFT_REQUEST_VOTE_RESULT: raft_message_type = 4;
pub const RAFT_INSTALL_SNAPSHOT: raft_message_type = 5;
pub const RAFT_TIMEOUT_NOW: raft_message_type = 6;
#[doc = " Type codes for RPC messages."]
pub type raft_message_type = ::std::os::raw::c_uint;
#[doc = " A single RPC message that can be sent or received over the network.\n\n The RPC message types all have a `version` field.\n In the libuv io implementation, `version` is filled out during decoding\n and is based on the size of the message on the wire, see e.g.\n `sizeofRequestVoteV1`. The version number in the RAFT_MESSAGE_XXX_VERSION\n macro needs to be bumped every time the message is updated.\n\n Notes when adding a new message type to raft:\n raft_io implementations compiled against old versions of raft don't know the\n new message type and possibly have not allocated enough space for it. When\n such an application receives a new message over the wire, the raft_io\n implementation will err out or drop the message, because it doesn't know how\n to decode it based on its type.\n raft_io implementations compiled against versions of raft that know the new\n message type but at runtime are linked against an older raft lib, will pass\n the message to raft, where raft will drop it.\n When raft receives a message and accesses a field of a new message type,\n the raft_io implementation must have known about the new message type,\n so it was compiled against a modern enough version of raft, and memory\n accesses should be safe.\n\n Sending a new message type with a raft_io implementation that doesn't know\n the type is safe, the implementation should drop the message based on its\n type and will not try to access fields it doesn't know the existence of."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raft_message {
    pub type_: raft_message_type,
    pub server_id: raft_id,
    pub server_address: *const ::std::os::raw::c_char,
    pub __bindgen_anon_1: raft_message__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union raft_message__bindgen_ty_1 {
    pub request_vote: raft_request_vote,
    pub request_vote_result: raft_request_vote_result,
    pub append_entries: raft_append_entries,
    pub append_entries_result: raft_append_entries_result,
    pub install_snapshot: raft_install_snapshot,
    pub timeout_now: raft_timeout_now,
}
#[doc = " Hold metadata associated with a snapshot."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_snapshot_metadata {
    pub index: raft_index,
    pub term: raft_term,
    pub configuration: raft_configuration,
    pub configuration_index: raft_index,
}
pub const RAFT_START: raft_event_type = 1;
pub const RAFT_RECEIVE: raft_event_type = 2;
pub const RAFT_PERSISTED_ENTRIES: raft_event_type = 3;
pub const RAFT_PERSISTED_SNAPSHOT: raft_event_type = 4;
pub const RAFT_CONFIGURATION: raft_event_type = 5;
pub const RAFT_SNAPSHOT: raft_event_type = 6;
pub const RAFT_TIMEOUT: raft_event_type = 7;
pub const RAFT_SUBMIT: raft_event_type = 8;
pub const RAFT_CATCH_UP: raft_event_type = 9;
pub const RAFT_TRANSFER: raft_event_type = 10;
#[doc = " Type codes of events to be passed to raft_step()."]
pub type raft_event_type = ::std::os::raw::c_uint;
#[doc = " Represents an external event that drives the raft engine forward (for example\n receiving a message or completing a task."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raft_event {
    pub time: raft_time,
    pub type_: raft_event_type,
    pub unused: ::std::os::raw::c_uchar,
    pub capacity: ::std::os::raw::c_ushort,
    pub reserved: [::std::os::raw::c_uchar; 4usize],
    pub __bindgen_anon_1: raft_event__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union raft_event__bindgen_ty_1 {
    pub start: raft_event__bindgen_ty_1__bindgen_ty_1,
    pub receive: raft_event__bindgen_ty_1__bindgen_ty_2,
    pub persisted_entries: raft_event__bindgen_ty_1__bindgen_ty_3,
    pub persisted_snapshot: raft_event__bindgen_ty_1__bindgen_ty_4,
    pub configuration: raft_event__bindgen_ty_1__bindgen_ty_5,
    pub snapshot: raft_event__bindgen_ty_1__bindgen_ty_6,
    pub submit: raft_event__bindgen_ty_1__bindgen_ty_7,
    pub catch_up: raft_event__bindgen_ty_1__bindgen_ty_8,
    pub transfer: raft_event__bindgen_ty_1__bindgen_ty_9,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_event__bindgen_ty_1__bindgen_ty_1 {
    pub term: raft_term,
    pub voted_for: raft_id,
    pub metadata: *mut raft_snapshot_metadata,
    pub start_index: raft_index,
    pub entries: *mut raft_entry,
    pub n_entries: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_event__bindgen_ty_1__bindgen_ty_2 {
    pub message: *mut raft_message,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_event__bindgen_ty_1__bindgen_ty_3 {
    pub index: raft_index,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_event__bindgen_ty_1__bindgen_ty_4 {
    pub metadata: raft_snapshot_metadata,
    pub offset: usize,
    pub last: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_event__bindgen_ty_1__bindgen_ty_5 {
    pub index: raft_index,
    pub conf: raft_configuration,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_event__bindgen_ty_1__bindgen_ty_6 {
    pub metadata: raft_snapshot_metadata,
    pub trailing: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_event__bindgen_ty_1__bindgen_ty_7 {
    pub entries: *mut raft_entry,
    pub n: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_event__bindgen_ty_1__bindgen_ty_8 {
    pub server_id: raft_id,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_event__bindgen_ty_1__bindgen_ty_9 {
    pub server_id: raft_id,
}
#[doc = " Hold information about changes that user code must perform after a call to\n raft_step() returns (e.g. new entries that must be persisted, new messages\n that must be sent, etc.)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_update {
    pub flags: ::std::os::raw::c_uint,
    pub entries: raft_update__bindgen_ty_1,
    pub snapshot: raft_update__bindgen_ty_2,
    pub messages: raft_update__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_update__bindgen_ty_1 {
    pub index: raft_index,
    pub batch: *mut raft_entry,
    pub n: ::std::os::raw::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_update__bindgen_ty_2 {
    pub metadata: raft_snapshot_metadata,
    pub offset: usize,
    pub chunk: raft_buffer,
    pub last: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_update__bindgen_ty_3 {
    pub batch: *mut raft_message,
    pub n: ::std::os::raw::c_uint,
}
pub const RAFT_UNAVAILABLE: raft_state = 0;
pub const RAFT_FOLLOWER: raft_state = 1;
pub const RAFT_CANDIDATE: raft_state = 2;
pub const RAFT_LEADER: raft_state = 3;
#[doc = " State codes."]
pub type raft_state = ::std::os::raw::c_uint;
#[doc = " Data structure for efficiently keeping track of the indexes of all entries in\n the log and of their terms."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_trail {
    pub records: *mut raft_trail__bindgen_ty_1,
    pub size: ::std::os::raw::c_uint,
    pub front: ::std::os::raw::c_uint,
    pub back: ::std::os::raw::c_uint,
    pub offset: raft_index,
    pub snapshot: raft_trail__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_trail__bindgen_ty_1 {
    pub index: raft_index,
    pub term: raft_term,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_trail__bindgen_ty_2 {
    pub index: raft_index,
    pub term: raft_term,
}
pub type raft_close_cb = ::std::option::Option<unsafe extern "C" fn(raft: *mut raft)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_progress {
    _unused: [u8; 0],
}
#[doc = " Hold and drive the state of a single raft server in a cluster.\n When replacing reserved fields in the middle of this struct, you MUST use a\n type with the same size and alignment requirements as the original type."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raft {
    pub tracer: *mut raft_tracer,
    pub id: raft_id,
    pub address: *mut ::std::os::raw::c_char,
    pub current_term: raft_term,
    pub voted_for: raft_id,
    pub __bindgen_anon_1: raft__bindgen_ty_1,
    pub configuration: raft_configuration,
    pub configuration_committed: raft_configuration,
    pub configuration_committed_index: raft_index,
    pub configuration_uncommitted_index: raft_index,
    pub election_timeout: ::std::os::raw::c_uint,
    pub heartbeat_timeout: ::std::os::raw::c_uint,
    pub install_snapshot_timeout: ::std::os::raw::c_uint,
    pub commit_index: raft_index,
    pub last_stored: raft_index,
    pub state: ::std::os::raw::c_ushort,
    pub __bindgen_anon_2: raft__bindgen_ty_2,
    pub election_timer_start: raft_time,
    pub snapshot: raft__bindgen_ty_3,
    pub errmsg: [::std::os::raw::c_char; 64usize],
    pub pre_vote: bool,
    pub max_catch_up_rounds: ::std::os::raw::c_uint,
    pub max_catch_up_round_duration: ::std::os::raw::c_uint,
    pub __bindgen_anon_3: raft__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union raft__bindgen_ty_1 {
    pub __bindgen_anon_1: raft__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft__bindgen_ty_1__bindgen_ty_1 {
    pub capacity: ::std::os::raw::c_ushort,
    pub capacity_threshold: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union raft__bindgen_ty_2 {
    pub follower_state: raft__bindgen_ty_2__bindgen_ty_1,
    pub candidate_state: raft__bindgen_ty_2__bindgen_ty_2,
    pub leader_state: raft__bindgen_ty_2__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raft__bindgen_ty_2__bindgen_ty_1 {
    pub randomized_election_timeout: ::std::os::raw::c_uint,
    pub current_leader: raft__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_1: raft__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub id: raft_id,
    pub address: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union raft__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    pub match_: raft_index,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft__bindgen_ty_2__bindgen_ty_2 {
    pub randomized_election_timeout: ::std::os::raw::c_uint,
    pub votes: *mut raft__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1,
    pub disrupt_leader: bool,
    pub in_pre_vote: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft__bindgen_ty_2__bindgen_ty_2__bindgen_ty_1 {
    pub grant: bool,
    pub features: ::std::os::raw::c_ushort,
    pub capacity: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raft__bindgen_ty_2__bindgen_ty_3 {
    pub progress: *mut raft_progress,
    pub promotee_id: raft_id,
    pub round_number: ::std::os::raw::c_ushort,
    pub round_index: raft_index,
    pub round_start: raft_time,
    pub __bindgen_anon_1: raft__bindgen_ty_2__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union raft__bindgen_ty_2__bindgen_ty_3__bindgen_ty_1 {
    pub __bindgen_anon_1: raft__bindgen_ty_2__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft__bindgen_ty_2__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub transferee: raft_id,
    pub transfer_start: raft_time,
    pub transferring: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raft__bindgen_ty_3 {
    pub __bindgen_anon_1: raft__bindgen_ty_3__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union raft__bindgen_ty_3__bindgen_ty_1 {
    pub __bindgen_anon_1: raft__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: raft__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft__bindgen_ty_3__bindgen_ty_1__bindgen_ty_1 {
    pub dummy: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft__bindgen_ty_3__bindgen_ty_1__bindgen_ty_2 {
    pub unused: bool,
    pub installing: bool,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union raft__bindgen_ty_4 {
    pub __bindgen_anon_1: raft__bindgen_ty_4__bindgen_ty_1,
    pub __bindgen_anon_2: raft__bindgen_ty_4__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft__bindgen_ty_4__bindgen_ty_1 {
    pub dummy: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft__bindgen_ty_4__bindgen_ty_2 {
    pub now: raft_time,
    pub random: ::std::os::raw::c_uint,
    pub messages: *mut raft_message,
    pub n_messages_cap: ::std::os::raw::c_uint,
    pub max_inflight_entries: ::std::os::raw::c_uint,
    pub configuration_last_snapshot_index: raft_index,
    pub update: *mut raft_update,
    pub trail: raft_trail,
    pub barrier: raft_entry,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_io {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_fsm {
    _unused: [u8; 0],
}
extern "C" {
    pub fn raft_init(
        r: *mut raft,
        io: *mut raft_io,
        fsm: *mut raft_fsm,
        id: raft_id,
        address: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn raft_close(r: *mut raft, cb: raft_close_cb);
}
extern "C" {
    #[doc = " Seed the state of the pseudo random number generator.\n\n This should be called only once, before calling raft_start()."]
    pub fn raft_seed(r: *mut raft, random: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Notify the raft engine of the given @event.\n\n The @commit_index output parameter will be filled with the index of the most\n recent entry known to be committed.\n\n The @timeout output parameter will be filled with the time at which the next\n timeout event should be fired. Any previously scheduled timeout that has not\n yet been fired should be cancelled.\n\n The @tasks output parameter will point to an array of @n_tasks pending tasks\n that should be performed.\n\n The memory of the @tasks array is guaranteed to be valid until the next call\n to raft_step(), and must be freed by consuming code.\n\n Tasks of type #RAFT_PERSIST_TERM_AND_VOTE must be carried out synchronously\n before any subsequent task (such as sending messages) is even started."]
    pub fn raft_step(
        r: *mut raft,
        event: *mut raft_event,
        update: *mut raft_update,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the current term of this server."]
    pub fn raft_current_term(r: *const raft) -> raft_term;
}
extern "C" {
    #[doc = " Return the ID of the server that this server has voted for, or #0 if it not\n vote."]
    pub fn raft_voted_for(r: *const raft) -> raft_id;
}
extern "C" {
    #[doc = " Return the commit index of this server."]
    pub fn raft_commit_index(r: *const raft) -> raft_index;
}
extern "C" {
    #[doc = " Return the time at which the next RAFT_TIMEOUT event should be fired."]
    pub fn raft_timeout(r: *const raft) -> raft_time;
}
extern "C" {
    #[doc = " Return the current match index of the server with the given ID.\n\n It must be called when in leader state."]
    pub fn raft_match_index(
        r: *const raft,
        id: raft_id,
        index: *mut raft_index,
    ) -> ::std::os::raw::c_int;
}
pub const RAFT_CATCH_UP_NONE: _bindgen_ty_3 = 0;
pub const RAFT_CATCH_UP_RUNNING: _bindgen_ty_3 = 1;
pub const RAFT_CATCH_UP_ABORTED: _bindgen_ty_3 = 2;
pub const RAFT_CATCH_UP_FINISHED: _bindgen_ty_3 = 3;
#[doc = " Return information about the progress of a server that is catching up with\n logs after a #RAFT_CATCH_UP event was fired."]
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
extern "C" {
    pub fn raft_catch_up(
        r: *const raft,
        id: raft_id,
        status: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the ID of the server that leadership is being transfered to, or #0 if\n no leadership transfer is in progress."]
    pub fn raft_transferee(r: *const raft) -> raft_id;
}
extern "C" {
    #[doc = " Set the election timeout.\n\n Every raft instance is initialized with a default election timeout of 1000\n milliseconds. If you wish to tweak it, call this function before starting\n your event loop.\n\n From Chapter 9:\n\n   We recommend a range that is 10-20 times the one-way network latency, which\n   keeps split votes rates under 40% in all cases for reasonably sized\n   clusters, and typically results in much lower rates.\n\n Note that the current random election timer will be reset and a new one\n will be generated."]
    pub fn raft_set_election_timeout(r: *mut raft, msecs: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Set the heartbeat timeout."]
    pub fn raft_set_heartbeat_timeout(r: *mut raft, msecs: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Set the snapshot install timeout."]
    pub fn raft_set_install_snapshot_timeout(r: *mut raft, msecs: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Enable or disable pre-vote support. Pre-vote is turned off by default."]
    pub fn raft_set_pre_vote(r: *mut raft, enabled: bool);
}
extern "C" {
    #[doc = " Set the maximum number of a catch-up rounds to try when replicating entries\n to a stand-by server that is being promoted to voter, before giving up and\n failing the configuration change. The default is 10."]
    pub fn raft_set_max_catch_up_rounds(r: *mut raft, n: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Set the maximum duration of a catch-up round when replicating entries to a\n stand-by server that is being promoted to voter. The default is 5 seconds."]
    pub fn raft_set_max_catch_up_round_duration(r: *mut raft, msecs: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " Set the maximum number of in-flight append messages that will be\n optimistically sent to peers without waiting for acknowledgment. The engine\n will stop sending more messages if this limit is reached. The default is 32.\n\n This limit also applies to entries being persisted locally and that haven't\n been acknowledged yet."]
    pub fn raft_set_max_inflight_entries(r: *mut raft, n: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " If a non-zero capacity threshold is set using this function, then the\n #capacity field of struct raft_event must be always set when calling\n raft_step(), and its value should contain the current amount of disk space\n that the server is guaranteed to have and can use when storing new entries.\n\n If the leader notices that a majority of voting server have their capacity\n below #min, then it will refuse to accept new entries. Calling raft_step()\n with a #RAFT_SUBMIT event will return #RAFT_NOSPACE."]
    pub fn raft_set_capacity_threshold(r: *mut raft, min: ::std::os::raw::c_ushort);
}
extern "C" {
    #[doc = " Return a human-readable description of the last error occurred."]
    pub fn raft_errmsg(r: *mut raft) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the code of the current raft state (follower/candidate/leader)."]
    pub fn raft_state(r: *mut raft) -> raft_state;
}
extern "C" {
    #[doc = " Return the code of the current raft role (spare/standby/voter),\n or -1 if this server is not in the current configuration."]
    pub fn raft_role(r: *mut raft) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the ID and address of the current known leader, if any."]
    pub fn raft_leader(r: *mut raft, id: *mut raft_id, address: *mut *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Return the index of the last entry that was appended to the local log."]
    pub fn raft_last_index(r: *mut raft) -> raft_index;
}
extern "C" {
    #[doc = " Generate a pseudo-random number between @min and @max, using @state as\n generator state."]
    pub fn raft_random(
        state: *mut ::std::os::raw::c_uint,
        min: ::std::os::raw::c_uint,
        max: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Return the name of state with the given code."]
    pub fn raft_state_name(state: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return the name of role with the given code."]
    pub fn raft_role_name(state: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
#[doc = " User-definable dynamic memory allocation functions.\n\n The @data field will be passed as first argument to all functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_heap {
    pub data: *mut ::std::os::raw::c_void,
    pub malloc: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub free: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, ptr: *mut ::std::os::raw::c_void),
    >,
    pub calloc: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            nmemb: usize,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub realloc: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            ptr: *mut ::std::os::raw::c_void,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub aligned_alloc: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            alignment: usize,
            size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub aligned_free: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            alignment: usize,
            ptr: *mut ::std::os::raw::c_void,
        ),
    >,
}
extern "C" {
    pub fn raft_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn raft_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn raft_calloc(nmemb: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn raft_realloc(
        ptr: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn raft_aligned_alloc(alignment: usize, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn raft_aligned_free(alignment: usize, ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " Use a custom dynamic memory allocator."]
    pub fn raft_heap_set(heap: *mut raft_heap);
}
extern "C" {
    #[doc = " Use the default dynamic memory allocator (from the stdlib). This clears any\n custom allocator specified with @raft_heap_set."]
    pub fn raft_heap_set_default();
}
extern "C" {
    #[doc = " Return a reference to the current dynamic memory allocator.\n\n This is intended for use by applications that want to temporarily replace\n and then restore the original allocator, or that want to defer to the\n original allocator in some circumstances.\n\n The behavior of attempting to mutate the default allocator through the\n pointer returned by this function, including attempting to deallocate\n the backing memory, is undefined."]
    pub fn raft_heap_get() -> *const raft_heap;
}
